{"version":3,"sources":["../src/ION.js"],"names":["fromJSONObject","toJSONText","highlightION","quoteString","str","match","arrayWarpedPrefix","e","i","objectWarpedPrefix","objectWarpedKey","key","quotedKey","repeat","length","objectWarpedKeyNext","returnedArray","concat","map","handleArray","object","recurFunc","remLen","res","flat","joined","join","notAtomic","some","includes","warpCond","handleObject","fullLen","keys","Object","resSameLine","k","val","warpSamelineCond","warpedSameLine","v","warpNextLineCond","resNextLine","warpedNextLine","fromJSONObjectRecursive","toString","toFixed","Array","isArray","lineLength","returnRightBracket","stack","pairs","type","text","lines","split","filter","resultText","currIndent","lineIndent","search","indent","pop","currLineRem","comma","trim","push","slice","quoted","simple","result","parsed","parseFloat","keyStyleString","keywordStyleString","t","replace"],"mappings":"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","file":"ION.js","sourcesContent":["/**\n * **QUOTE STRING** \n *\n * If a string contains character '@' or a white space, then\n * quote it with quotation mark. This happens when converting\n * a JSON string into ION one.\n *\n * @param {string} str input string\n *\n */\nfunction quoteString(str){\n    return str.match(/[ @]/) ? '\"' + str + '\"' : str;\n}\n\n/**\n * **ARRAY WARPED PREFIX**\n *\n * With the line index given, this function inserts either the\n * array prefix (@) or the indentation white space before each\n * array element.\n *\n * @param {string} e element\n * @param {number} i index\n */\nfunction arrayWarpedPrefix(e, i){\n    return (i == 0 ? \"@ \" : \"  \") + e;\n}\n\n/**\n * **OBJECT WARPED PREFIX**\n *\n * With the line index given, this function inserts either the\n * object prefix (#) or the indentation white space before each\n * object entry.\n *\n * @param {string} e element\n * @param {number} i element index\n */\nfunction objectWarpedPrefix(e, i){\n    return (i == 0 ? \"# \" : \"  \") + e;\n}\n\n/**\n * **OBJECT WARPED KEY**\n *\n * After processed the value of each key-value pair, which means\n * the value has been turned into a string, this function turns\n * the key-value pair into the final form and add white space to\n * align them.\n *\n * @param {string} e element\n * @param {number} i index\n * @param {stirng} key the key followed by\n */\nfunction objectWarpedKey(e, i, key){\n    var quotedKey = quoteString(key);\n    return (i == 0 ? quotedKey + \": \" : \" \".repeat(quotedKey.length+2)) + e;\n}\n\n/**\n * **OBJECT WARPED KEY NEXT**\n *\n * if the final string of the ION key-value pair is much shorter\n * than the given length, then this function gathers several lines\n * into one line, so that to save lines.\n *\n * @param {string} returnedArray array of element returned from next level\n * @param {*} key the key of current key-value pair\n */\nfunction objectWarpedKeyNext(returnedArray, key){\n    return [key+\":\"].concat(returnedArray.map( e=> \" \" + e));\n}\n\n/**\n * process if an array of next level is identified.\n * @param {object} object sub-level of object.\n * @param {function} recurFunc the call-back recursive function.\n * @param {number} remLen remaining length of current line\n */\nfunction handleArray(object, recurFunc, remLen){\n    var res       = object.map((e) => recurFunc(e, remLen - 2)).flat(),\n        joined    = res.join(' '),\n        notAtomic = res.some(e => e.includes(\"@\") || e.includes(\"#\")),\n        warpCond  = ( notAtomic || joined.length > remLen);\n        \n    return (warpCond) ? res.map(arrayWarpedPrefix) : [\"@ \" + joined];\n}\n\n\nfunction handleObject(object, recurFunc, remLen, fullLen){\n    var keys           = Object.keys(object),\n        resSameLine    = keys.map((k) => ({key:k, val:recurFunc(object[k], remLen - k.length, fullLen)})),\n        notAtomic      = resSameLine.map(e => e.val.some(e => e.includes(\"@\") || e.includes(\"#\"))).some(e=>e),\n        \n        joined           = resSameLine.map((e) => quoteString(e.key) + \": \" + e.val[0]).join(\" \"),\n        warpSamelineCond = ( notAtomic || joined.length > remLen),\n        warpedSameLine   = resSameLine.map((e) => e.val.map((v, i) => objectWarpedKey(v, i, e.key))).flat(),\n\n        warpNextLineCond = warpedSameLine.some(e => e.length > fullLen),\n        resNextLine = keys.map((k) => ({key:k, val:recurFunc(object[k], remLen - 2, fullLen)})),\n        warpedNextLine   = resNextLine.map((e) => objectWarpedKeyNext(e.val, e.key)).flat();\n        \n    return (warpNextLineCond) ? warpedNextLine.map(objectWarpedPrefix) :\n           (warpSamelineCond) ? warpedSameLine.map(objectWarpedPrefix) : [\"# \" + joined];\n}\n\n/**\n * fromJSONObject\n * \n * @param {object} object object to be interpreted\n * @param {number} currCursor the current place of interpreted string\n * @param {number} nextLineCursor the position where the warped line starts\n * \n * @returns {object} an array of string\n */\nfunction fromJSONObjectRecursive(object, remLen, fullLen){\n\n    switch(typeof object){\n        case \"string\":\n            return [quoteString(object)];\n        case \"number\":\n\n            return [ object % 1 == 0 ? object.toString() : object.toFixed(3)];\n        case \"object\":\n            var res = (Array.isArray(object)) \n                      ? handleArray(object, fromJSONObjectRecursive, remLen)\n                      : handleObject(object, fromJSONObjectRecursive, remLen, fullLen);\n            \n            return res;\n    }\n}\n\nexport function fromJSONObject(object, lineLength){\n    return fromJSONObjectRecursive(object, lineLength, lineLength).join(\"\\n\");\n}\n\n\nfunction returnRightBracket(stack){\n    var pairs = {\"{\": \"}\", \"[\": \"]\", \":\":\"\"};\n    return pairs[stack[stack.length - 1].type];\n}\n\n//  The only thing that really matter is the end of indentation.\n//  so this function will scan the text line by line, word by word.\n//  when meet @, push stack with [, and # with { . when encounter\n//  the \", find the next \" and append to text with string, or anything \n//  end with space or comma.\nexport function toJSONText(text){\n    \n    var lines = text.split(\"\\n\").filter(e => !e.match(/^\\s*$/));\n    \n    var resultText = \"\",\n        stack      = [],\n        currIndent = 0;\n\n    for (let i = 0; i < lines.length; i++){\n\n        var lineIndent = lines[i].search(/\\S|$/);\n        while (stack.length > 0 && stack[stack.length - 1].indent >= lineIndent){\n            resultText += returnRightBracket(stack);\n            stack.pop();\n        }\n\n        currIndent = 0;\n        var currLineRem = lines[i];\n        \n        while(currLineRem.length > 0){\n            switch(currLineRem[0]){\n                case \" \":\n                    // a space, might be a delimiter (comma)\n                    \n                    if (stack[stack.length - 1].comma)\n                        resultText += \", \";\n                    else\n                        stack[stack.length - 1].comma = true;\n\n                    currIndent  += currLineRem.search(/\\S|$/);\n                    currLineRem  = currLineRem.trim();\n                    break;\n\n                case \"@\": \n                    // beginning of an arary\n                    resultText += \"[\"; stack.push({type:\"[\", indent: currIndent, comma:false});\n                    currIndent += 1;\n                    currLineRem = currLineRem.slice(1);\n                    break;\n\n                case \"#\":\n                    // beginning of an object\n                    resultText += \"{\"; stack.push({type:\"{\", indent: currIndent, comma:false});\n                    currIndent += 1;\n                    currLineRem = currLineRem.slice(1);\n                    break;\n\n                case \":\":\n                    resultText += \":\"; stack.push({type:\":\", indent: currIndent});\n                    currIndent += 1;\n                    currLineRem = currLineRem.slice(1);\n                    break;\n\n                case '\"':\n                    // beginning of a quoted string. Notably, we don't accept\n                    // a single quotation mark appearing on a single line.\n\n                    var quoted = currLineRem.match(/\"(?:\\\\\"|[^\"])*\"/);\n                    if (!quoted) throw \"Quoted string missing at Line: \" + i;\n                    \n                    if (stack.length > 0 && stack[stack.length - 1].type == \":\") stack.pop();\n                    currIndent += quoted[0].length;\n                    resultText += currLineRem.slice(0, quoted[0].length);\n                    currLineRem = currLineRem.slice(quoted[0].length);\n                    break;\n\n\n                default :\n                    // means we meet a simple string, that a string doesn't\n                    // contains space, and quotation marks on both ends.\n                    // however, it's okay to contain a single quotation mark\n                    // in the middle of the string.\n                    // console.log(\"gotcha\");\n                    var simple = currLineRem.match(/[^\\s:]*/);\n                    if (!simple) throw \"Simple string got some problem at Line: \" + 1;\n                    if (stack.length > 0 && stack[stack.length - 1].type == \":\") {stack.pop();}\n\n                    currIndent += simple[0].length;\n\n                    var result = currLineRem.slice(0, simple[0].length),\n                        parsed = parseFloat(result) ;\n                    \n                    resultText += (!parsed && parsed != 0) ? '\"' + result + '\"' : parsed;\n\n                    currLineRem = currLineRem.slice(simple[0].length);\n                    break;\n\n            }\n        }\n    }\n\n    while (stack.length > 0 && stack[stack.length - 1].indent >= 0){\n        resultText += returnRightBracket(stack);\n        stack.pop();\n    }\n\n    return resultText;\n}\n\nexport function highlightION(text, keyStyleString, keywordStyleString){\n    return text.split('\\n').map(t=> t\n        .replace(/(\\S+\\s*)(?=:)/g, '<b class=\"'+keyStyleString+'\">$1</b>')\n        .replace(/([#@:])/g, '<b class=\"'+keywordStyleString+'\">$1</b>'))\n        .join('\\n');\n}\n"]}